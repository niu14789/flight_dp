/**********************************************************************************************************
* Copy right      : Botan high tech.
* Description     : GPS NMEA 4.0 parse
* File  Name      : GpsNmea.c

History:
Author               Date                  version
Ryan Huang         2019-04-03              V1.0
**********************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "SerialPort.h"
#include "GpsNmea.h"


#define SUB_TYPE_NUMBER 6

extern void DelayMs(uint32_t dwTimeMs);

/**
* NMEA packets type which parsed and generated by library
*/
typedef enum _NMEA_PACK_TYPE_
{
    GPRMC=0, /**00< RMC - Recommended Minimum Specific GPS/TRANSIT Data. */
    GPVTG,   /**01< VTG - Actual track made good and speed over ground. */
    GPGGA,   /**02< GGA - Essential fix data which provide 3D location and accuracy data. */
    GPGLL,   /**03< GLL - packet information structure (Recommended Minimum sentence C).**/
    GPGSV,   /**04< GSV - Number of SVs in view, PRN numbers, elevation, azimuth & SNR values. */
    GPGSA,   /**05< GSA - GPS receiver operating mode, SVs used for navigation, and DOP values. */

    GNRMC,   /**06< RMC - 推荐的最少专用航向数据 */
    GNVTG,   /**07< VTG - 对地速度和航向 */
    GNGGA,   /**08< GGA - 接收机定位数据，详细*/
    GNGLL,   /**09< GLL - 地理位置 经纬度 */
    GNGSV,   /**10< GSV - 可见卫星 */
    GNGSA,   /**11< GGA - 精度因子和参与计算的卫星 */

    GLRMC,   /**12< RMC - 推荐的最少专用航向数据 */
    GLVTG,   /**13< VTG - 对地速度和航向 */
    GLGGA,   /**14< GGA - 接收机定位数据，详细*/
    GLGLL,   /**15< GLL - 地理位置 经纬度 */
    GLGSV,   /**16< GSV - 可见卫星 */
    GLGSA,   /**17< GGA - 精度因子和参与计算的卫星 */

    BDRMC,   /**18< RMC - 推荐的最少专用航向数据 */
    BDVTG,   /**19< VTG - 对地速度和航向 */
    BDGGA,   /**20< GGA - 接收机定位数据，详细*/
    BDGLL,   /**21< GLL - 地理位置 经纬度 */
    BDGSV,   /**22< GSV - 可见卫星 */
    BDGSA,   /**23< GGA - 精度因子和参与计算的卫星 */
    GPNON,   /**24< Unknown packet type. */

}NMEA_PACK_TYPE;



typedef enum _NMEA_ITEM_TYPE_
{
    NMEA_ITEM_UNUSE = 0,
    NMEA_ITEM_DATE, // UTC日期，转换前格式为"ddmmyy"；转换后3个无符号整数表示，分别为8位（日，取值1~31）+8位（月，取值1~12）+8位（年，取值1~99，加上2000就对应真实年份）
    NMEA_ITEM_DECLINATION,
    NMEA_ITEM_DIRECTION,
    NMEA_ITEM_ELV,     // Altitude海拔高度
    NMEA_ITEM_FIX_CHAR,   // 单个固定字符
    NMEA_ITEM_HDOP,  // 精度因子。转换前取值范围0.000到99.999；转换后为32为无符号整数后且取值范围为0~99999，单位为0.001的。
    NMEA_ITEM_MODE,
    NMEA_ITEM_LATITUDE,  // 纬度。转换前格式为ddmm.mmmmm，转换后为32位有符号整数mmmmmmmmm且单位为0.00001分。
    NMEA_ITEM_LATITUDE_NS,
    NMEA_ITEM_LONGITUDE, // 经度。转换前格式为dddmm.mmmmm，转换后为32位有符号整数mmmmmmmmm且单位为0.00001分。
    NMEA_ITEM_LONGITUDE_EW,
    NMEA_ITEM_PDOP,  // 精度因子。转换前取值范围0.000到99.999；转换后为32为无符号整数后且取值范围为0~99999，单位为0.001的。
    NMEA_ITEM_POSITIONING_QUALITY,
    NMEA_ITEM_POSITIONING_STATUS_FLAG,
    NMEA_ITEM_SAT_INFO_AZIMUTH,
    NMEA_ITEM_SAT_INFO_ELV,
    NMEA_ITEM_SAT_INFO_ID,
    NMEA_ITEM_SAT_INFO_SIG,
    NMEA_ITEM_SAT_INUSE,
    NMEA_ITEM_SIGNAL_FIX,  // 单个可变字符，可取值为A或V，对应会改变sig和fix。
    NMEA_ITEM_SOG,     // 对地速度，单位为0.001节
    NMEA_ITEM_SOG_SPEED,     // 对地速度，单位为0.001节
    NMEA_ITEM_SPEED,   // 对地速度，单位为0.001Km/H
    NMEA_ITEM_TIME, // UTC时间，转换前格式为"hhmmss.sss"；转换后用4个无符号整数表示，分别为8位（时，取值0~23，单位时）+8位（分，取值0~59，单位分）+8位（秒，取值0~59，单位秒）+8位（百分秒，取值0~99，单位0.01秒）
    NMEA_ITEM_VDOP,  // 精度因子。转换前取值范围0.000到99.999；转换后为32为无符号整数后且取值范围为0~99999，单位为0.001的。
}NMEA_ITEM_TYPE;



#define GGA_FIELD_NUMBER   14
#define VTG_FIELD_NUMBER   9
#define RMC_FIELD_NUMBER   12
#define GSV_FIELD_NUMBER   19
#define GSA_FIELD_NUMBER   17
#define GLL_FIELD_NUMBER   7

typedef struct _NMEA_ITEM_DESCRIPTION_
{
    NMEA_ITEM_TYPE eType;
    char cFixValue;
}NMEA_ITEM_DESCRIPTION;


#define NMEA_MAX_FIELD_NUMBER  25

typedef struct _NMEA_FIELD_
{
    int iFieldCount;
    NMEA_PACK_TYPE ePackType;
    char *strFieldPoint[NMEA_MAX_FIELD_NUMBER];
}NMEA_FIELD;

int MyMemCmp(U8 *pbyA, U8*pbyB, int iLen)
{
    int i;

    for (i = 0; i < iLen; i++)
    {
        if (pbyA[i] > pbyB[i])
        {
            return 1;
        }
        else if (pbyA[i] < pbyB[i])
        {
            return -1;
        }
    }
    return 0;
}

void MyMemSet(U8 *pbyIn, U8 byInit, int iLen)
{
    int i;

    for (i = 0; i < iLen; i++)
    {
        pbyIn[i] = byInit;
    }
}


// 0:success, <0:error
static int s_ParseFloatStringToInt(char *strLineIn, int iDecimalPartLen, int *piResultOut)
{
    int iStart = 0, iPointFlag = 0, iDecimalPartCount = 0;
    int aiMulti[6] = { 1,10,100,1000,10000,100000 };

#ifdef _DEBUG_VERSION_ 
    if ((NULL == strLineIn) && (NULL == piResultOut))
    {
        return -1;
    }
#endif
    if ((iDecimalPartLen > 5) || (iDecimalPartLen < 0))
    {
        return -1;
    }
    *piResultOut = 0;
    for (iStart = 0; iStart < 9; iStart++)
    {
        if ((strLineIn[iStart] >= '0') && (strLineIn[iStart] <= '9'))
        {
            *piResultOut *= 10;
            *piResultOut += strLineIn[iStart] - '0';
            if (0 != iPointFlag)
            {
                iDecimalPartCount++;
                if (iDecimalPartCount >= iDecimalPartLen)
                {
                    break;
                }
            }
        }
        else if ('.' == strLineIn[iStart])
        {
            if (0 == iDecimalPartLen)
            {
                break;
            }
            if (0 == iPointFlag)
            {
                iPointFlag = 1;
            }
            else
            {
                return -2;
            }
        }
        else
        {
            break;
        }
    }
    *piResultOut *= aiMulti[iDecimalPartLen - iDecimalPartCount];
    return 0;
}

static int s_ParseLatitudeLongitude(char *strLineIn, int iIsLatitude, int *piResultOut)
{
    int iOffset, iTemp, iRet;
#ifdef _DEBUG_VERSION_ 
    if ((NULL == strLineIn) && (NULL == piResultOut))
    {
        return -1;
    }
#endif
    if ((strLineIn[0] >= '0') && (strLineIn[0] <= '9'))
    {
        *piResultOut = strLineIn[0] - '0';
    }
    else
    {
        return -1;
    }
    if ((strLineIn[1] >= '0') && (strLineIn[1] <= '9'))
    {
        *piResultOut *= 10;
        *piResultOut += strLineIn[1] - '0';
    }
    else
    {
        return -2;
    }
    if (0 != iIsLatitude)
    {
        iOffset = 2;
    }
    else
    {
        if ((strLineIn[2] >= '0') && (strLineIn[2] <= '9'))
        {
            *piResultOut *= 10;
            *piResultOut += strLineIn[2] - '0';
        }
        else
        {
            return -3;
        }
        iOffset = 3;
    }
    iRet = s_ParseFloatStringToInt(&strLineIn[iOffset], 5, &iTemp);
    if (0 != iRet)
    {
        return -4;
    }
    *piResultOut *= 6000000;
    *piResultOut += iTemp;
    return (iOffset + iRet);
}


static int s_CheckMsgStringType(char *strSrcMsgIn)
{
    int iType;
#ifdef _DEBUG_VERSION_ 
    if (NULL == strSrcMsgIn)
    {
        return -1;
    }
#endif
    if (0 == MyMemCmp((U8*)strSrcMsgIn, (U8*)"$GP", 3))
    {
        iType = 0;
    }
    else if (0 == MyMemCmp((U8*)strSrcMsgIn, (U8*)"$GN", 3))
    {
        iType = 6;
    }
    else if (0 == MyMemCmp((U8*)strSrcMsgIn, (U8*)"$GL", 3))
    {
        iType = 12;
    }
    else if (0 == MyMemCmp((U8*)strSrcMsgIn, (U8*)"$BD", 3))
    {
        iType = 18;
    }
    else
    {
        return -2;
    }
    if (0 == MyMemCmp((U8*)&strSrcMsgIn[3], (U8*)"RMC,", 4))
    {
        return iType;
    }
    else if (0 == MyMemCmp((U8*)&strSrcMsgIn[3], (U8*)"VTG,", 4))
    {
        return (iType + 1);
    }
    else if (0 == MyMemCmp((U8*)&strSrcMsgIn[3], (U8*)"GGA,", 4))
    {
        return (iType + 2);
    }
    else if (0 == MyMemCmp((U8*)&strSrcMsgIn[3], (U8*)"GLL,", 4))
    {
        return (iType + 3);
    }
    else if (0 == MyMemCmp((U8*)&strSrcMsgIn[3], (U8*)"GSV,", 4))
    {
        return (iType + 4);
    }
    else if (0 == MyMemCmp((U8*)&strSrcMsgIn[3], (U8*)"GSA,", 4))
    {
        return (iType + 5);
    }
    else
    {
        return -3;
    }
}

static int s_LineSliceToField(char *strSrcMsgIn, char *strDstMsgOut, NMEA_FIELD *poFieldOut)
{
    int i, j, iRet;

#ifdef _DEBUG_VERSION_ 
    if ((NULL == strSrcMsgIn) || (NULL == strDstMsgOut) || (NULL == poFieldOut))
    {
        return -1;
    }
#endif

    i = 0;
    while ('$' != strSrcMsgIn[i])
    {
        i++;
    }
    j = 0;
    while (1)
    {
        if ((0x0d == strSrcMsgIn[i]) || (0x0a == strSrcMsgIn[i]) || (0x00 == strSrcMsgIn[i]))
        {
            strDstMsgOut[j] = 0x00;
            break;
        }
        strDstMsgOut[j++] = strSrcMsgIn[i++];
    }
    if (j < 10)
    {
        return -2;
    }
    iRet = s_CheckMsgStringType(strDstMsgOut);
    if (iRet < 0)
    {
        return iRet; // unknow message format
    }
    poFieldOut->iFieldCount = 0;
    poFieldOut->ePackType = (NMEA_PACK_TYPE)iRet;
    poFieldOut->strFieldPoint[0] = &strDstMsgOut[7];
    poFieldOut->iFieldCount++;
    for (i = 7; i < j; i++)
    {
        if (',' == strDstMsgOut[i])
        {
            poFieldOut->strFieldPoint[poFieldOut->iFieldCount] = &strDstMsgOut[i + 1];
            poFieldOut->iFieldCount++;
            strDstMsgOut[i] = 0;
        }
        else if ('*' == strDstMsgOut[i])
        {
            strDstMsgOut[i] = 0;
            return 0;
        }
    }
    // we have not checked the data field valid or not
    return 0;
}

static int s_PickUtcTime(char *strTime, NMEA_INFO *poInfoOut)
{
    // "hhmmss.sss"
    int i;
#ifdef _DEBUG_VERSION_ 
    if ((NULL == strTime) || (NULL == poInfoOut))
    {
        return -1;
    }
#endif
    if ('.' != strTime[6])
    {
        return -1;
    }
    strTime[6] = strTime[7];
    strTime[7] = strTime[8];
    strTime[8] = strTime[9];
    // "hhmmsssss"
    for (i = 0; i < 9; i++)
    {
        if ((strTime[i] < '0') && (strTime[i] > '9'))
        {
            return -2;
        }
    }
    poInfoOut->m_oUtcDateTime.m_byHour = strTime[0] - '0';
    poInfoOut->m_oUtcDateTime.m_byHour *= 10;
    poInfoOut->m_oUtcDateTime.m_byHour += strTime[1] - '0';
    poInfoOut->m_oUtcDateTime.m_byMin = strTime[2] - '0';
    poInfoOut->m_oUtcDateTime.m_byMin *= 10;
    poInfoOut->m_oUtcDateTime.m_byMin += strTime[3] - '0';
    poInfoOut->m_oUtcDateTime.m_bySec = strTime[4] - '0';
    poInfoOut->m_oUtcDateTime.m_bySec *= 10;
    poInfoOut->m_oUtcDateTime.m_bySec += strTime[5] - '0';
    poInfoOut->m_oUtcDateTime.m_byHsec = strTime[6] - '0';
    poInfoOut->m_oUtcDateTime.m_byHsec *= 10;
    poInfoOut->m_oUtcDateTime.m_byHsec += strTime[7] - '0';
    poInfoOut->m_oUtcDateTime.m_byHsec *= 10;
    poInfoOut->m_oUtcDateTime.m_byHsec += strTime[8] - '0';
    return 0;
}

static int s_PickUtcDate(char *strDate, NMEA_INFO *poInfoOut)
{
    // "ddmmyy"
    int i;
#ifdef _DEBUG_VERSION_ 
    if ((NULL == strDate) || (NULL == poInfoOut))
    {
        return -1;
    }
#endif
    for (i = 0; i < 6; i++)
    {
        if ((strDate[i] < '0') && (strDate[i] > '9'))
        {
            return -1;
        }
    }
    poInfoOut->m_oUtcDateTime.m_byDay = strDate[0] - '0';
    poInfoOut->m_oUtcDateTime.m_byDay *= 10;
    poInfoOut->m_oUtcDateTime.m_byDay += strDate[1] - '0';

    poInfoOut->m_oUtcDateTime.m_byMon = strDate[2] - '0';
    poInfoOut->m_oUtcDateTime.m_byMon *= 10;
    poInfoOut->m_oUtcDateTime.m_byMon += strDate[3] - '0';

    poInfoOut->m_oUtcDateTime.m_byYear = strDate[4] - '0';
    poInfoOut->m_oUtcDateTime.m_byYear *= 10;
    poInfoOut->m_oUtcDateTime.m_byYear += strDate[5] - '0';
    return 0;
}

static NMEA_ITEM_DESCRIPTION gs_aoGLL[GLL_FIELD_NUMBER] = {
    { NMEA_ITEM_LATITUDE ,     0 },   // field 1
    { NMEA_ITEM_LATITUDE_NS ,  0 },   // field 2
    { NMEA_ITEM_LONGITUDE ,    0 },   // field 3
    { NMEA_ITEM_LONGITUDE_EW , 0 },   // field 4
    { NMEA_ITEM_TIME ,         0 },   // field 5
    { NMEA_ITEM_SIGNAL_FIX ,   0 },   // field 6
    { NMEA_ITEM_MODE ,       'N' }    // field 7, if the char is 'N' then mean the line is invalid
};

// 参与计算的卫星
static NMEA_ITEM_DESCRIPTION gs_aoGSA[GSA_FIELD_NUMBER] = {
    { NMEA_ITEM_UNUSE ,                      0 },    // field  1
    { NMEA_ITEM_POSITIONING_STATUS_FLAG , '1' },    // field  2  Positioning status flag, if the char is '1' then mean the line is invalid
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  3
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  4
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  5
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  6
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  7
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  8
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field  9
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field 10
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field 11
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field 12
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field 13
    { NMEA_ITEM_SAT_INUSE ,                  0 },    // field 14
    { NMEA_ITEM_PDOP ,                       0 },    // field 15
    { NMEA_ITEM_HDOP ,                       0 },    // field 16
    { NMEA_ITEM_VDOP ,                       0 }     // field 17
};

// 可见卫星
static NMEA_ITEM_DESCRIPTION gs_aoGSV[GSV_FIELD_NUMBER] = {
    { NMEA_ITEM_UNUSE ,            0 },    // field  1
    { NMEA_ITEM_UNUSE ,            0 },    // field  2
    { NMEA_ITEM_UNUSE ,            0 },    // field  3
    { NMEA_ITEM_SAT_INFO_ID ,      0 },    // field  4
    { NMEA_ITEM_SAT_INFO_ELV ,     0 },    // field  5
    { NMEA_ITEM_SAT_INFO_AZIMUTH , 0 },    // field  6
    { NMEA_ITEM_SAT_INFO_SIG ,     0 },    // field  7
    { NMEA_ITEM_SAT_INFO_ID ,      0 },    // field  8
    { NMEA_ITEM_SAT_INFO_ELV ,     0 },    // field  9
    { NMEA_ITEM_SAT_INFO_AZIMUTH , 0 },    // field 10
    { NMEA_ITEM_SAT_INFO_SIG ,     0 },    // field 11
    { NMEA_ITEM_SAT_INFO_ID ,      0 },    // field 12
    { NMEA_ITEM_SAT_INFO_ELV ,     0 },    // field 13
    { NMEA_ITEM_SAT_INFO_AZIMUTH , 0 },    // field 14
    { NMEA_ITEM_SAT_INFO_SIG ,     0 },    // field 15
    { NMEA_ITEM_SAT_INFO_ID ,      0 },    // field 16
    { NMEA_ITEM_SAT_INFO_ELV ,     0 },    // field 17
    { NMEA_ITEM_SAT_INFO_AZIMUTH , 0 },    // field 18
    { NMEA_ITEM_SAT_INFO_SIG ,     0 },    // field 19
};

static NMEA_ITEM_DESCRIPTION gs_aoRMC[RMC_FIELD_NUMBER] = {
    { NMEA_ITEM_TIME ,         0 },   // field  1
    { NMEA_ITEM_SIGNAL_FIX ,   0 },   // field  2
    { NMEA_ITEM_LATITUDE ,     0 },   // field  3
    { NMEA_ITEM_LATITUDE_NS ,  0 },   // field  4
    { NMEA_ITEM_LONGITUDE ,    0 },   // field  5
    { NMEA_ITEM_LONGITUDE_EW , 0 },   // field  6
    { NMEA_ITEM_SOG_SPEED ,    0 },   // field  7
    { NMEA_ITEM_UNUSE ,        0 },   // field  8
    { NMEA_ITEM_DATE ,         0 },   // field  9
    { NMEA_ITEM_UNUSE ,        0 },   // field 10
    { NMEA_ITEM_UNUSE ,        0 },   // field 11
    { NMEA_ITEM_MODE ,       'N' }    // field 12
};

static NMEA_ITEM_DESCRIPTION gs_aoVTG[VTG_FIELD_NUMBER] = {
    { NMEA_ITEM_DIRECTION ,     0 },   // field 1
    { NMEA_ITEM_FIX_CHAR ,    'T' },   // field 2
    { NMEA_ITEM_DECLINATION ,   0 },   // field 3
    { NMEA_ITEM_FIX_CHAR ,    'M' },   // field 4
    { NMEA_ITEM_SOG ,           0 },   // field 5
    { NMEA_ITEM_FIX_CHAR ,    'N' },   // field 6
    { NMEA_ITEM_SPEED ,         0 },   // field 7
    { NMEA_ITEM_FIX_CHAR ,    'K' },   // field 8
    { NMEA_ITEM_MODE ,        'N' }    // field 9, if mode=='N' then this string is invalid
};

static NMEA_ITEM_DESCRIPTION gs_aoGGA[GGA_FIELD_NUMBER] = {
    { NMEA_ITEM_TIME ,                0 },  // field 1
    { NMEA_ITEM_LATITUDE ,            0 },  // field 2
    { NMEA_ITEM_LATITUDE_NS ,         0 },  // field 3
    { NMEA_ITEM_LONGITUDE ,           0 },  // field 4
    { NMEA_ITEM_LONGITUDE_EW ,        0 },  // field 5
    { NMEA_ITEM_POSITIONING_QUALITY , 0 },  // field 6
    { NMEA_ITEM_UNUSE ,               0 },  // field 7 satellite inuse
    { NMEA_ITEM_HDOP ,                0 },  // field 8
    { NMEA_ITEM_ELV ,                 0 },  // field 9
    { NMEA_ITEM_FIX_CHAR ,          'M' },  // field 10
    { NMEA_ITEM_UNUSE ,               0 },  // field 11
    { NMEA_ITEM_FIX_CHAR ,          'M' },  // field 12
    { NMEA_ITEM_UNUSE ,               0 },  // field 13
    { NMEA_ITEM_UNUSE ,               0 }   // field 14
};

static int s_FieldListToInfo(NMEA_FIELD *poFieldIn, NMEA_ITEM_DESCRIPTION *poDescriptionLineIn, int iDescriptNumber, NMEA_INFO *poInfoOut)
{
    int i, j, iRet, iTemp, iStop;

#ifdef _DEBUG_VERSION_ 
    if ((NULL == poFieldIn) || (NULL == poDescriptionLineIn) || (NULL == poInfoOut))
    {
        return -1;
    }
#endif

    iStop = poFieldIn->iFieldCount;
    if (iStop > iDescriptNumber)
    {
        iStop = iDescriptNumber;
    }
    // Check fix field char valid or invalid
    for (i = 0; i < iStop; i++)
    {
        if ((NMEA_ITEM_FIX_CHAR == poDescriptionLineIn[i].eType)
            && (poFieldIn->strFieldPoint[i][0] != poDescriptionLineIn[i].cFixValue))
        {
            return -2;
        }
        if ((NMEA_ITEM_MODE == poDescriptionLineIn[i].eType)
            && (poFieldIn->strFieldPoint[i][0] == poDescriptionLineIn[i].cFixValue))
        {
            return -3;
        }
        if ((NMEA_ITEM_POSITIONING_STATUS_FLAG == poDescriptionLineIn[i].eType)
            && (poFieldIn->strFieldPoint[i][0] == poDescriptionLineIn[i].cFixValue))
        {
            return -3;
        }
    }
    for (i = 0; i < iStop; i++)
    {
        switch (poDescriptionLineIn[i].eType)
        {
        case NMEA_ITEM_DIRECTION:
            if (',' != poFieldIn->strFieldPoint[i][0])
            {
                iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 2, &iTemp);
                if (iRet >= 0)
                {
                    poInfoOut->m_iDirection = iTemp;
                }
            }
            break;
        case NMEA_ITEM_DECLINATION:
            if (',' != poFieldIn->strFieldPoint[i][0])
            {
                iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 2, &iTemp);
                if (iRet >= 0)
                {
                    poInfoOut->m_iDeclination = iTemp;
                }
            }
            break;
        case NMEA_ITEM_POSITIONING_QUALITY:
            if (('0' != poFieldIn->strFieldPoint[i][0]) && ('1' != poFieldIn->strFieldPoint[i][0]) && ('6' != poFieldIn->strFieldPoint[i][0]))
            {
                return -4; // invalid string item
            }
            poInfoOut->m_byPositioningQuality = poFieldIn->strFieldPoint[i][0] - '0';
            break;
        case NMEA_ITEM_POSITIONING_STATUS_FLAG:
            if (('2' != poFieldIn->strFieldPoint[i][0]) && ('3' != poFieldIn->strFieldPoint[i][0]))
            {
                poInfoOut->m_byPositionStateFlag = 1;
                return -4; // invalid string item
            }
            poInfoOut->m_byPositionStateFlag = poFieldIn->strFieldPoint[i][0] - '0';
            break;
        case NMEA_ITEM_ELV:
            if (0x00 == poFieldIn->strFieldPoint[i][0])
            {
                return -4; // invalid string item
            }
            if ('-' == poFieldIn->strFieldPoint[i][0])
            {
                iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][1], 2, &iTemp);
                if (iRet >= 0)
                {
                    poInfoOut->m_iAltitude = -iTemp;
                }
            }
            else
            {
                iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 2, &iTemp);
                if (iRet >= 0)
                {
                    poInfoOut->m_iAltitude = iTemp;
                }
            }
            break;
        case NMEA_ITEM_SOG:
            if (0x00 == poFieldIn->strFieldPoint[i][0])
            {
                return -4; // invalid string item
            }
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 3, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_iSpeedKnot = iTemp;
            }
            break;
        case NMEA_ITEM_SOG_SPEED:
            if (0x00 == poFieldIn->strFieldPoint[i][0])
            {
                return -4; // invalid string item
            }
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 3, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_iSpeedKnot = iTemp;
                poInfoOut->m_iSpeedMH = poInfoOut->m_iSpeedKnot * 1852;
                poInfoOut->m_iSpeedMH /= 1000;
            }
            break;
        case NMEA_ITEM_SPEED:
            if (0x00 == poFieldIn->strFieldPoint[i][0])
            {
                return -4; // invalid string item
            }
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 3, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_iSpeedMH = iTemp;
            }
            break;
        case NMEA_ITEM_FIX_CHAR:
            if (poFieldIn->strFieldPoint[i][0] != poDescriptionLineIn[i].cFixValue)
            {
                return -4; // invalid string item
            }
            break;
        case NMEA_ITEM_DATE:
            if ((poFieldIn->strFieldPoint[i][0] < '0') || (poFieldIn->strFieldPoint[i][0] > '9'))
            {
                return -4; // invalid string item
            }
            // "ddmmyy"
            s_PickUtcDate(&poFieldIn->strFieldPoint[i][0], poInfoOut);
            break;
        case NMEA_ITEM_TIME:
            if ((poFieldIn->strFieldPoint[i][0] < '0') || (poFieldIn->strFieldPoint[i][0] > '9'))
            {
                return -4; // invalid string item
            }
            // "hhmmss.sss"
            s_PickUtcTime(&poFieldIn->strFieldPoint[i][0], poInfoOut);
            break;
        case NMEA_ITEM_SIGNAL_FIX:
            if ('A' == poFieldIn->strFieldPoint[i][0])
            {
                if (0 == poInfoOut->m_byPositioningQuality)
                {
                    poInfoOut->m_byPositioningQuality = 2;
                }
                if (1 == poInfoOut->m_byPositionStateFlag)
                {
                    poInfoOut->m_byPositionStateFlag = 2;
                }
            }
            else if ('V' == poFieldIn->strFieldPoint[i][0])
            {
                poInfoOut->m_byPositioningQuality = 0;
                poInfoOut->m_byPositionStateFlag = 1;
            }
            break;
        case NMEA_ITEM_MODE:
            poInfoOut->m_cMode = poFieldIn->strFieldPoint[i][0];
            break;
        case NMEA_ITEM_LATITUDE_NS:
            if ('S' == poFieldIn->strFieldPoint[i][0])
            {
                if (poInfoOut->m_iLatitude > 0)
                {
                    poInfoOut->m_iLatitude = -poInfoOut->m_iLatitude;
                }
            }
            break;
        case NMEA_ITEM_LONGITUDE_EW:
            if ('W' == poFieldIn->strFieldPoint[i][0])
            {
                if (poInfoOut->m_iLongitude > 0)
                {
                    poInfoOut->m_iLongitude = -poInfoOut->m_iLongitude;
                }
            }
            break;
        case NMEA_ITEM_LATITUDE:
            iRet = s_ParseLatitudeLongitude(&poFieldIn->strFieldPoint[i][0], 1, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_iLatitude = iTemp;
            }
            break;
        case NMEA_ITEM_LONGITUDE:
            iRet = s_ParseLatitudeLongitude(&poFieldIn->strFieldPoint[i][0], 0, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_iLongitude = iTemp;
            }
            break;
        case NMEA_ITEM_UNUSE:
            break;
        case NMEA_ITEM_PDOP: // 取值范围0.000到99.999
        case NMEA_ITEM_HDOP: // 取值范围0.000到99.999
        case NMEA_ITEM_VDOP: // 取值范围0.000到99.999
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 3, &iTemp);
            if (iRet >= 0)
            {
                if (NMEA_ITEM_PDOP == poDescriptionLineIn[i].eType)
                {
                    poInfoOut->m_iPDOP = iTemp;
                }
                else if (NMEA_ITEM_HDOP == poDescriptionLineIn[i].eType)
                {
                    poInfoOut->m_iHDOP = iTemp;
                }
                else
                {
                    poInfoOut->m_iVDOP = iTemp;
                }
            }
            break;
        case NMEA_ITEM_SAT_INUSE:
            if (0 == poFieldIn->strFieldPoint[i][0])
            {
                break;
            }
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 0, &iTemp);
            if (iRet >= 0)
            {
                for (j = 0; j < poInfoOut->m_oSatInfo.m_wVisible; j++)
                {
                    if (iTemp == poInfoOut->m_oSatInfo.m_aoList[j].m_dwID)
                    {
                        poInfoOut->m_oSatInfo.m_aoList[j].m_dwUseFlag = 1;
                        poInfoOut->m_oSatInfo.m_wInuse++;
                        break;
                    }
                }
            }
            break;
        case NMEA_ITEM_SAT_INFO_ID:
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 0, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_oSatInfo.m_aoList[poInfoOut->m_oSatInfo.m_wVisible].m_dwID = iTemp;
            }
            break;
        case NMEA_ITEM_SAT_INFO_ELV:
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 0, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_oSatInfo.m_aoList[poInfoOut->m_oSatInfo.m_wVisible].m_dwElv = iTemp;
            }
            break;
        case NMEA_ITEM_SAT_INFO_AZIMUTH:
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 0, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_oSatInfo.m_aoList[poInfoOut->m_oSatInfo.m_wVisible].m_dwSignal = iTemp;
            }
            break;
        case NMEA_ITEM_SAT_INFO_SIG:
            iRet = s_ParseFloatStringToInt(&poFieldIn->strFieldPoint[i][0], 0, &iTemp);
            if (iRet >= 0)
            {
                poInfoOut->m_oSatInfo.m_aoList[poInfoOut->m_oSatInfo.m_wVisible].m_dwAzimuth = iTemp;
            }
            poInfoOut->m_oSatInfo.m_wVisible++;
            break;
        default:
            break;
        }
    }

    return 0;
}


static int s_StringToLineListAndSort(char *strStringIn, NMEA_SRING_LIST *poLineListOut)
{
    int i, iHead, iTail, iRet, iTemp;
    char *strTemp;

#ifdef _DEBUG_VERSION_ 
    if ((NULL == strStringIn) || (NULL == poLineListOut))
    {
        return -1;
    }
#endif

    poLineListOut->m_iLineNumber = 0;
    i = 0;
    while (poLineListOut->m_iLineNumber < MAX_LINE_NUMBER)
    {
        if (0 == strStringIn[i])
        {
            break;
        }
        if ('$' == strStringIn[i])
        {
            iRet = s_CheckMsgStringType(&strStringIn[i]);
            if (iRet >= 0)
            {
                poLineListOut->strLineAddr[poLineListOut->m_iLineNumber] = &strStringIn[i];
                poLineListOut->m_aiLineType[poLineListOut->m_iLineNumber] = iRet;
                poLineListOut->m_aiSubType[poLineListOut->m_iLineNumber] = iRet % SUB_TYPE_NUMBER;
                poLineListOut->m_iLineNumber++;
            }
        }
        i++;
    }
    iHead = 0;
    iTail = poLineListOut->m_iLineNumber - 1;
    while (iHead < iTail)
    {
        if (GPGSA == poLineListOut->m_aiSubType[iHead])
        {
            while (iHead < iTail)
            {
                if (GPGSA != poLineListOut->m_aiSubType[iTail])
                {
                    strTemp = poLineListOut->strLineAddr[iHead];
                    iRet = poLineListOut->m_aiLineType[iHead];
                    iTemp = poLineListOut->m_aiSubType[iHead];
                    poLineListOut->strLineAddr[iHead] = poLineListOut->strLineAddr[iTail];
                    poLineListOut->m_aiLineType[iHead] = poLineListOut->m_aiLineType[iTail];
                    poLineListOut->m_aiSubType[iHead] = poLineListOut->m_aiSubType[iTail];
                    poLineListOut->strLineAddr[iTail] = strTemp;
                    poLineListOut->m_aiLineType[iTail] = iRet;
                    poLineListOut->m_aiSubType[iTail] = iTemp;
                    iTail--;
                    iHead++;
                    break;
                }
                else
                {
                    iTail--;
                }
            }
        }
        else
        {
            iHead++;
        }
    }
    return 0;
}

// 0:at lease has one valid string, other: failed
int s_StringToInfo(char *strStringIn, NMEA_INFO *poInfoOut)
{
    NMEA_FIELD oField;
    int iRet, i, iFlag;
    char strTempFieldString[128];
    NMEA_SRING_LIST oLineList;

    if ((NULL == strStringIn) || (NULL == poInfoOut))
    {
        return -1;
    }

    iRet = s_StringToLineListAndSort(strStringIn, &oLineList);

    MyMemSet((U8*)poInfoOut, 0x00, sizeof(NMEA_INFO));
    iFlag = 0;
    for (i = 0; i < oLineList.m_iLineNumber; i++)
    {
        MyMemSet((U8*)&oField, 0x00, sizeof(NMEA_FIELD));
        s_LineSliceToField((char*)oLineList.strLineAddr[i], strTempFieldString, &oField); // RMC test
        switch (oField.ePackType)
        {
        case GPVTG:
        case GNVTG:
        case GLVTG:
        case BDVTG:
            iRet = s_FieldListToInfo(&oField, gs_aoVTG, VTG_FIELD_NUMBER, poInfoOut);
            break;
        case GPRMC:
        case GNRMC:
        case GLRMC:
        case BDRMC:
            iRet = s_FieldListToInfo(&oField, gs_aoRMC, RMC_FIELD_NUMBER, poInfoOut);
            break;
        case GPGSV:
        case GNGSV:
        case GLGSV:
        case BDGSV:
            iRet = s_FieldListToInfo(&oField, gs_aoGSV, GSV_FIELD_NUMBER, poInfoOut);
            break;
        case GPGSA:
        case GNGSA:
        case GLGSA:
        case BDGSA:
            iRet = s_FieldListToInfo(&oField, gs_aoGSA, GSA_FIELD_NUMBER, poInfoOut);
            break;
        case GPGGA:
        case GNGGA:
        case GLGGA:
        case BDGGA:
            iRet = s_FieldListToInfo(&oField, gs_aoGGA, GGA_FIELD_NUMBER, poInfoOut);
            break;
        case GPGLL:
        case GNGLL:
        case GLGLL:
        case BDGLL:
            iRet = s_FieldListToInfo(&oField, gs_aoGLL, GLL_FIELD_NUMBER, poInfoOut);
            break;
        default:
            iRet = 1;
            break;
        }
        if (0 == iRet)
        {
            iFlag = 1;
        }
    }
    if (1 == iFlag)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

#define GPS_BUFFER_LENGTH  1024
#define GPS_BUFFER_VALID     1
#define GPS_BUFFER_INVALID   0

static SerialPortHandle *g_pGpsPortHandle = NULL;
static unsigned char gs_pbyGpsReadBuff[GPS_BUFFER_LENGTH];
static int gs_iGpsSaveDataLen = 0;

//UBLOX NEO-6M UART端口设置结构体
__packed typedef struct _UBLOX_CFG_PORT_
{
    U16 wHeader;                    //cfg header,固定为0X62B5(小端模式)
    U16 wId;                        //CFG PRT ID:0X0006 (小端模式)
    U16 wDataLength;                   //数据长度 20
    U8  byPortId;                    //端口号,0=IIC;1=UART1;2=UART2;3=USB;4=SPI;
    U8  byRev;                  //保留,设置为0
    U16 wTxReady;                   //TX Ready引脚设置,默认为0
    U32 dwMode;                      //串口工作模式设置,奇偶校验,停止位,字节长度等的设置.
    U32 dwBaudRate;                  //波特率设置
    U16 wInProtoMask;               //输入协议激活屏蔽位  默认设置为0X07 0X00即可.
    U16 wOutProtoMask;              //输出协议激活屏蔽位  默认设置为0X07 0X00即可.
    U16 wReserved4;                 //保留,设置为0
    U16 wReserved5;                 //保留,设置为0 
    U8  byCka;                       //校验CK_A                                   
    U8  byCkb;                       //校验CK_B                                  
}UBLOX_CFG_PORT;

__packed typedef struct _UBLOX_CFG_RATE_
{
    U16 wHeader;                 //cfg header,固定为0X62B5(小端模式)
    U16 wId;                     //CFG RATE ID:0X0806 (小端模式)
    U16 wDataLength;                //数据长度
    U16 wMeasRate;               //测量时间间隔，单位为ms，最少不能小于200ms（5Hz）
    U16 wNavRate;                //导航速率（周期），固定为1
    U16 wTimeRef;                //参考时间：0=UTC Time；1=GPS Time；
    U8  byCka;                    //校验CK_A                                   
    U8  byCkb;                    //校验CK_B                                  
}UBLOX_CFG_RATE;

//GPS校验和计算
//buf:数据缓存区首地址
//len:数据长度
//cka,ckb:两个校验结果.
void NmeaCheckSum(U8 *pbyData, U16 wDataLen, U8 *pbyCka, U8*pbyCkb)
{
    U16 i;
    *pbyCka = 0; *pbyCkb = 0;
    for (i = 0; i < wDataLen; i++)
    {
        *pbyCka = *pbyCka + pbyData[i];
        *pbyCkb = *pbyCkb + *pbyCka;
    }
}


//配置NMEA输出信息格式
//baudrate:波特率,4800/9600/19200/38400/57600/115200/230400      
//返回值:0,执行成功;其他,执行失败(这里不会返回0了)
int UbloxCfgPortBauds(U32 dwBaudRate)
{
    UBLOX_CFG_PORT oCfgPort;

    oCfgPort.wHeader = 0x62b5;
    oCfgPort.wId = 0x0006;
    oCfgPort.wDataLength = 20;
    oCfgPort.byPortId = 1;
    oCfgPort.byRev = 0;
    oCfgPort.wTxReady = 0;
    oCfgPort.dwMode = 0x08D0;        //8位,1个停止位,无校验位
    oCfgPort.dwBaudRate = dwBaudRate;//波特率设置
    oCfgPort.wInProtoMask = 0x0007;  //0+1+2
    oCfgPort.wOutProtoMask = 0x0007; //0+1+2
    oCfgPort.wReserved4 = 0;
    oCfgPort.wReserved5 = 0;
    NmeaCheckSum((U8*)(&oCfgPort.wId), sizeof(UBLOX_CFG_PORT) - 4, &oCfgPort.byCka, &oCfgPort.byCkb);
    UsartSendNoBlocking(g_pGpsPortHandle, (U8*)&oCfgPort, sizeof(UBLOX_CFG_PORT));
    DelayMs(200); //等待发送完成 
    UsartChangeBauds(g_pGpsPortHandle, dwBaudRate);
    UsartCleanReceiveBuffer(g_pGpsPortHandle);
    return 0;
}


int s_GpsInit(USART_PORT ePort, int iBauds)
{
//    UsartInit(ePort);
    gs_iGpsSaveDataLen = 0;
    g_pGpsPortHandle = UsartOpen(ePort);
    if (NULL == g_pGpsPortHandle)
    {
        return -1; // open port failed
    }
    else
    {
        return 0; // open port success
    }
}


//1s  at lease call one time
int s_GpsCheckBufferValid(U8 *pbyBuff, int iSaveLen)
{
    int iValidCount = 0, i, j;

    if (iSaveLen < 7)
    {
        return GPS_BUFFER_INVALID;
    }
    i = 0;
    while (i < iSaveLen)
    {
        if (0 == MyMemCmp(&pbyBuff[i], (U8*)"$GNRMC,", 7))
        {
            iValidCount += 1;
            break;
        }
        i++;
    }
    j = 0;
    while (j < iSaveLen)
    {
        if (0 == MyMemCmp(&pbyBuff[j], (U8*)"$GNGLL,", 7))
        {
            iValidCount += 1;
            break;
        }
        j++;
    }
    if ((2 == iValidCount) && ((i+170) < j))
    {
        return GPS_BUFFER_VALID;
    }
    return GPS_BUFFER_INVALID;
}

int GpsInit(void)
{
    int iRet, iLen = 0;
    U32 dwStartTimeMs, dwCurTimeMs;
    static U8 s_abySetBauds115200bps[37]   = {0xB5, 0x62, 0x06, 0x00, 0x14, 0x00, 0x01, 0x00, 
                                       0x00, 0x00, 0xD0, 0x08, 0x00, 0x00, 0x00, 0xC2, 
                                       0x01, 0x00, 0x07, 0x00, 0x03, 0x00, 0x00, 0x00, 
                                       0x00, 0x00, 0xC0, 0x7E, 0xB5, 0x62, 0x06, 0x00, 
                                       0x01, 0x00, 0x01, 0x08, 0x22};
    static U8 s_abySetReportRate10Hz[22]   = {0xB5, 0x62, 0x06, 0x08, 0x06, 0x00, 0x64, 0x00, 
                                       0x01, 0x00, 0x01, 0x00, 0x7A, 0x12, 0xB5, 0x62, 
                                       0x06, 0x08, 0x00, 0x00, 0x0E, 0x30};

    iRet = s_GpsInit(USART_PORT0, 9600);
    if (0 != iRet)
    {
        return -1;
    }
    UsartCleanReceiveBuffer(g_pGpsPortHandle);
    iLen = 0;
    dwStartTimeMs = GetTickCountMs();
    while (iLen < 100)
    {
        dwCurTimeMs = GetTickCountMs();
        if ((dwCurTimeMs - dwStartTimeMs) > 6000)
        {
            return -2;
        }
        iRet = UsartGetRecvBufferlen(g_pGpsPortHandle);
        if (iRet > 0)
        {
            iLen += iRet;
        }
    }
    UsartSendNoBlocking(g_pGpsPortHandle, (const U8*)s_abySetBauds115200bps, sizeof(s_abySetBauds115200bps));
    DelayMs(100);
    UsartSendNoBlocking(g_pGpsPortHandle, (const U8*)s_abySetBauds115200bps, sizeof(s_abySetBauds115200bps));
    DelayMs(100);
    iRet = s_GpsInit(USART_PORT0, 115200);
    if (0 != iRet)
    {
        return -3;
    }
    UsartCleanReceiveBuffer(g_pGpsPortHandle);
    iLen = 0;
    dwStartTimeMs = GetTickCountMs();
    while (iLen < 100)
    {
        dwCurTimeMs = GetTickCountMs();
        if ((dwCurTimeMs - dwStartTimeMs) > 2000)
        {
            return -4;
        }
        iRet = UsartGetRecvBufferlen(g_pGpsPortHandle);
        if (iRet > 0)
        {
            iLen += iRet;
        }
    }
    UsartSendNoBlocking(g_pGpsPortHandle, (const U8*)s_abySetReportRate10Hz, sizeof(s_abySetReportRate10Hz));
    DelayMs(30);
    UsartCleanReceiveBuffer(g_pGpsPortHandle);
    return 0;
}




#ifdef _DEBUG_VERSION_
// 0:has update, 1:not update, other:failed
int GpsGetNmeaInfo(NMEA_INFO *poNmeaInfo, SerialPortBaseDefine *pDebugPort)
#else
int GpsGetNmeaInfo(NMEA_INFO *poNmeaInfo)
#endif
{

#ifdef _DEBUG_VERSION_
    char *strMessage = "------\r\n";
    char *strMessageValid = "\r\nValue\r\n";
    char strBuff[40];
    int iLen;
#endif
    int iRet;

    if (NULL == g_pGpsPortHandle)
    {
        return -1; // open port failed
    }
    else
    {
        if (gs_iGpsSaveDataLen >= GPS_BUFFER_LENGTH)
        {
            gs_iGpsSaveDataLen = 0; // clear save buffer
        }
        iRet = UsartRecvNoBlocking(g_pGpsPortHandle, &gs_pbyGpsReadBuff[gs_iGpsSaveDataLen], GPS_BUFFER_LENGTH - gs_iGpsSaveDataLen);
        if (iRet > 0)
        {
#ifdef _DEBUG_VERSION_
//            UsartSendNoBlocking(pDebugPort, strMessage, 8);
            iLen = sprintf(strBuff, "------%d\r\n", gs_iGpsSaveDataLen);
            UsartSendNoBlocking(pDebugPort, strBuff, iLen);
            UsartSendNoBlocking(pDebugPort, &gs_pbyGpsReadBuff[gs_iGpsSaveDataLen], iRet);
            UsartSendNoBlocking(pDebugPort, strMessage, 8);
#endif
            if (GPS_BUFFER_VALID == s_GpsCheckBufferValid(gs_pbyGpsReadBuff, gs_iGpsSaveDataLen+iRet))
            {
#ifdef _DEBUG_VERSION_
            UsartSendNoBlocking(pDebugPort, strMessageValid, 9);
#endif
                iRet = s_StringToInfo((char*)gs_pbyGpsReadBuff, poNmeaInfo);
                gs_iGpsSaveDataLen = 0; // clear save buffer
                return iRet;
            }
            else
            {
                gs_iGpsSaveDataLen += iRet;
            }
        }
        return 2;
    }
}


